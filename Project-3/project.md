
# Unit 3: Mr.Restro

<img width="531" alt="Screenshot 2025-03-10 at 11 58 36 PM" src="https://github.com/user-attachments/assets/2085c439-8e2d-4ec9-b4cf-a6d657ece063" />


# Criteria A: Planning


## Problem Definition

Mr. M, the manager of MR. M Restro, is facing immense challenges in managing his restaurant and growing his business. Despite his efforts, his restaurant still relies on outdated methods, like collecting customer reviews and ratings through paper forms. Advertising is done via posters and pamphlets, which are largely ignored in today’s digital age. These methods have not only become inconvenient for customers, but they’ve also backfired, leaving Mr. M struggling to keep up with competitors.
He has tried various approaches, such as posting on social media and tracking data trends manually in spreadsheets, but these methods are cumbersome, time-consuming, and ultimately inefficient. His employees are burdened with the task of conducting surveys and brainstorming ways to attract customers, leaving little time or energy to focus on what truly matters: serving food and creating a great dining experience. The customers also really struggle to get the right preference of their taste on dishes and a manage budget for it and its also very difficult to navigate and get proper guidance on Mr.M Restro. The supplies of ingredients to Mr.M Restro also struggle to store and supply the ingredients to the restaurant as they don’t have the proper data and information to supply.
To make matters worse, the highly competitive nature of the restaurant industry makes it increasingly difficult for MR. M Retro to stand out. Just last month, Mr. M’s restaurant was on the brink of bankruptcy. This wake-up call made him realize that the old methods could no longer sustain his business in a fast-evolving market.
Watching his employees work tirelessly, distributing cards and pamphlets, only to see them grow exhausted and discouraged, has taken a toll on Mr. M both personally and professionally. The strain has deeply affected both his life and his business. 



## Proposed Solution

To help overcome these challenges of Mr.M Retro (restaurants), I propose a data-driven digital food platform that connects restaurants, users, and food suppliers where Mr.M Restro can advertise their menu and add new dishes and features on that platform. Users or food critics can write reviews and rate it each dish as well as see others' reviews and ratings. Users can also choose and sort the dishes according to their preferences and taste, and see the average price, distance, and location of Mr.M Restro branches. To make it a more engaging and gamified experience the platform will show today's special dishes to try on and display the highest-rated dishes with positive reviews. The user will be accompanied with very powerful ai trained model chatbot which can provide any response related to the Mr.M restro as well as food related queries. It will help the users to navigate the user throught the platform which will boost their engagement and experience. For the restaurant, they will be able to put the details of the specialty on the platform. For the producer, they will be able to see the graph and trend between the rating and the dishes. And furthermore they can download the graph and analyze the graph more closely and get the information which ingredients and supplies to include in their inventory and supplies to the restaurant. The solution here will help Mr.M restro to boost so much as the platform will help all the major supplies and connected people of restaurants.


## Success Criteria

1. Users and food critics can provide reviews and ratings on each dish in the Mr.M restaurant. <br>
 *Issue tackle: “his restaurant still relies on outdated methods, like collecting customer reviews and ratings through paper forms.”*
2. Allow restaurants to advertise their special dishes and cuisine digitally on the Mr. Restro platform.<br>
   *Issue tackle: “ Advertising is done via posters and pamphlets, which are largely ignored in today’s digital age.”*
3. The platform will allow producer to see the graph and trends over dishes and their dishes.<br>
*Issued tackle: “ The supplies of ingredients to Mr.M retro also struggle to store and supplies the ingredients to restaurant as they don’t have proper data and information to supplies.”*
4. The platform will have a chatbot that will assist users in navigating through the Mr.M restro.<br>
 *Issued tackle:  “very difficult to navigate and get proper guidance on Mr.M Restro”*
5. The user can see others reviews and get short insight into dishes before trying.<br>
 *Issued tackle: "The customers also really struggle to get the right preference of their taste on dishes."*
6. The platform must  show the prices, tastes and cuisine details of each dishes on menu.<br>
*Issue tackle: “ The customers also really struggle to get the right preference of their taste on dishes and a manage budget for it”*




# Criteria B: Solution Overview


## System diagram
<img width="1489" alt="Screenshot 2025-03-11 at 12 00 10 AM" src="https://github.com/user-attachments/assets/cb422a01-2c86-48f6-b798-c822a0a6e12d" />

*Fig. 1* illustrates the system, its parts, inputs, and output. The relationships between them are shown as well. The application takes user input from the keyboard and mouse, the computer details and the software it's running are included in the diagram. The python environment is VS-Code, in which two coding languages, python and KivyMD are ran. They interact with the relational database "project.db" inside the Vs-Code environment. The output is displayed on a screen.

## ER diagram
![Screenshot 2025-03-11 at 0 06 04 AM](https://github.com/user-attachments/assets/4502c09e-32d4-42d8-9fd8-54bcf6a104a5)




*Fig. 3* is ER diagram shows the tables in the database "project_3.db" and there relationships. 
## UML diagram

![Screenshot 2025-03-11 at 0 08 17 AM](https://github.com/user-attachments/assets/5aba717e-7ddf-43c0-8a59-26b9720d38b7)





*Fig. 4* is UML diagram shows the classes and their methods used in developing this application. The lines and arrows illustrate the inheritance relationship. Most of the classes used in the application either inherit from Screen class.



## Flow diagrams


### Registration



![Screenshot 2025-03-11 at 12 21 48 AM](https://github.com/user-attachments/assets/27c95cf3-8d13-43e5-b48f-2533876ea80e)






*Fig. 1* is the flow diagram for the registration.

###  Display the reviews

![Screenshot 2025-03-11 at 12 23 36 AM](https://github.com/user-attachments/assets/932a38fd-1390-447b-8ac0-0857dcf69b3c)

*Fig. 2* is the flow diagram for the displaying reviews


###  Login

![Screenshot 2025-03-11 at 12 25 20 AM](https://github.com/user-attachments/assets/bef13be3-002f-4e51-b199-12250cb4f2b1)



*Fig. 2* is the flow diagram for login.



# Record of Task

| Task no: | Planned Action                                         | Planned Outcome                                                                                                                                           | Time Estimate | Targeted Completion date | Criteria |
|----------|--------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------|---------------|--------------------------|----------|
| 1        | Planning: Write problem definition                     | Meet with client and finalize a description of the problem.                                                                                               | 35 min        | 1/30/2025                | A        |
| 2        | Planning: Meet Again with client                       | record, clarify and finalize the problem defination                                                                                                       | 20 min        | 2/1/2025                 | A        |
| 3        | Planning: Email client                                 | Email client for the success criteria.                                                                                                                    | 15 min        | 2/3/2025                 | A        |
| 4        | Planning: Finalize success criteria                    | Email back about the confirming and finalizing the set criteria                                                                                           | 15 min        | 2/5/2025                 | A        |
| 5        | Planning: Present propose solution                     | Present and get feedback from client about your proposed solution, method and tools you will be using                                                     | 25 min        | 2/8/2025                 | A        |
| 6        | Planning:  Finalize Propose solution                   | Write propose solution with the clients feedbacks.                                                                                                        | 35 min        | 2/9/2025                 | A        |
| 7        | Design: Create a system diagram                        | draw system diagram on the what are the inputs, application, storage and use of computer architecture.                                                    | 25 min        | 2/10/2025                | B        |
| 8        | Design: Brainstorming                                  | planning roughtly on what libraries and what will be needed for the applicaiton.                                                                          | 25            | 2/10/2025                | B        |
| 9        | Design: Sketch the simple gui                          | Sketching the simple gui on paper and how it should look.                                                                                                 | 25 min        | 2/10/2025                | B        |
| 10       | Planning: Choosing the right version                   | choosing the most compatable and stable python version and kivy version as well as VS-code                                                                | 15 min        | 2/11/2025                | C        |
| 11       | Design: install/Uninstall requirments                  | Installing the requirments and neccesarry package                                                                                                         | 15 min        | 2/11/2025                | C        |
| 12       | Planning: setting lab                                  | creating and activating virtual environment                                                                                                               | 15 min        | 2/11/2025                | C        |
| 13       | Implementation: start coding                           | First start working on the login page                                                                                                                     | 3 hrs         | 2/12/2025                | B        |
| 14       | Implementation: password security                      | hashing the password                                                                                                                                      | 30 min        | 2/13/2025                | C        |
| 15       | Implementation: setting storage(database)              | setting sqlite3 as storage for password and other neccessary data                                                                                         | 1 hr          | 2/14/2025                | B        |
| 16       | Implementation: connect to database                    | retrive, format and write on database throught python sqlite module via kivy GUI                                                                          | 1 hr          | 2/15/2025                | C        |
| 17       | Design: Enhance the coloring                           | choosing the right button, size, features on login screen.                                                                                                | 1 hr          | 2/16/2025                | B        |
| 18       | Implementation: adding features                        | able to login or either create new account from login screen.                                                                                             | 30 min        | 2/16/2025                | C        |
| 19       | Implementation: security features                      | show message how many attempts left and at set attemps able to send email to admin with stmp/redirect to blocked page                                     | 2 hours       | 2/17/2025                | B        |
| 20       | Implementation: start working on second screen         | code for home screen, which has three tab(users, resturent,producers) instead of screenmanager.                                                           | 30 min        | 2/18/2025                | B        |
| 21       | Implementation:  put button which is global            | the button like sign out and chatbots which display in all tab should be place first.                                                                     | 30 min        | 2/18/2025                | C        |
| 22       | Implementation: create an content for users            | create an interactive button which show, input food reviews and ratings.                                                                                  | 2 hrs         | 2/20/2025                | D        |
| 23       | Design: sorting algorithm                              | create a button that fetch data from database of rating and sort the food according to the aggreagrade rating.                                            | 2 hrs         | 2/21/2025                | D        |
| 24       | Design and Implementation:  Add dishes by user         | create a button that allows users to add their dishes and name which will save to database                                                                | 2 hrs         | 2/23/2025                | B        |
| 25       | Design/ Implementation: start working on resturent tab | at the branches of the Mr.M resturent, with functionality to search them by name. when press on restrent image show details, location, cusine, avg price. | 1 hr          | 2/24/2025                | C        |
| 26       | add more sorting algorithm                             | able to sort according to price, taste, location and budgets.                                                                                             | 1:30 hr       | 2/25/2025                | B        |
| 27       | Design/ Implementation: start working on producer tab  | add a graph that is plot with dishes name on its rating by fetching these data from database.                                                             | 2 hrs         | 2/26/2025                | C        |
| 28       | Implementation: make downloadable graph                | make that graph downloadable for producers to analyze futher.                                                                                             | 1 hrs         | 2/26/2025                | A        |
| 29       | Implementation:  start working on chatbot              | research on study about Ai integration                                                                                                                    | 2 hrs         | 2/27/2025                | B        |
| 30       | Implementation: get know about API                     | research on LLM API and training model with huggingface                                                                                                   | 1 hrs         | 2/29/2025                | C        |
| 31       | Testing and Debugging: Api Integration                 | feed the data about Mr.M restro and other necessary data on deepseek model with groq Api                                                                  | 2 hrs         | 2/30/2025                | B        |
| 32       | Implementation: GUI for chatbot                        | connect groq with kivy framework for interface. take input, proccess and display                                                                          | 3hrs          | 3/2/2025                 | C        |
| 33       | Testing and Debugging: Test all the functionality      | check if all the fucntionallity is working and try to fixes any bugs.                                                                                     | 35 min        | 3/5/2025                 | C        |
| 34       | Deployment: Meet with clients and Do MVP               | Do MVP and get feedbacks.                                                                                                                                 | 20 min        | 3/7/2025                 | B        |
| 35       | Edit                                                   | Customize and change according to the clients feedback and requirement                                                                                    | 1 hr          | 3/9/2025                 | C        |
| 36       | Deployment/ maintanance handOver(Payday)               | Hand the product to clients and get pay                                                                                                                   | 30 min        | 3/10/2025                | D        |
| 37       | Design/ Deployment Meet Criteria D                     | Record Vide showing the facilities of the application and upload it on github.                                                                            | 30 min        | 3/12/2025                | D        |
| 38       |                                                        |                                                                                                                                                           |               |                          |          |



# Task Plan


| Test No | Test Type                                                                    | Date | Procedure                                                                                                                                                                                                                                                                                                   | Expected Outcome                                                                                                                                           |
|---------|------------------------------------------------------------------------------|------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1       | Funtionalities: users data entries on dishes                                 | 3/7  | Run the login.py file and then enter the login details email:test1@gmail.com password: test123# press login button. After successful login navigate to the Users tab by pressing the Users button below the tab,  press on a dish and then enter reviews string and press on stars and press submit button. | Users are able to write reviews and stared  the rating on the specific food.                                                                               |
| 2       | Funtionalities: dishes should automatically sort when button is press        | 3/8  | After that press the add button below the tab and choose the image  file and then name it as desired and then press on the sort button and see if the dishes are  arrange according to the ratings in descending order.                                                                                     | resturants can add their desired dishes and  advertise their menu.                                                                                         |
| 3       | Funtionalitites: Test on Visual Data on graph with Matplotlib and kivygarden | 3/9  | After that Press on the producer's tab below which is near the users tab,  and press the download button download the image and save it desired name.                                                                                                                                                       | Producers are able to visually see the graph  plotted on rating trends over the dishes and  download the graph as jpeg image on device for futher analyze. |
| 4       | Funtionalities: Chatbot service Testing                                      | 3/9  | After that on any tab Press on the blue chatbot image in the the  right corner of the screen,  queries any question on the input section hinted with type here,  asks about recipes, restaurants , rating of Mr.M retro.                                                                                    | should guide the users, provide answers to any questions  related to the Mr.M restro and have full capacity to chat around                                 |
| 5       | Funtionalities: Testing reviews and rating system                            | 3/9  | Press the close button for the chatbot and then press the user's tab. You will see the list of restaurants and then you simply Press on a dish, then press on the see reviews button.                                                                                                                       | Should display the reviews from all users, filter null value from db and display the ratings which is valid only.                                          |
| 6       | Funtionalities: Testing the all the dishes detail information                | 3/10 | After that press "X" button to close the dialog box of review. navigate to resturant tab by pressing which is below the screen near the users , press on one cusine and see the information, press "X" to close and then check on different Menu again.                                                     | Should display the details of the menus, like prices, tastes, l ocation, and cuision details.                                                              |


# Criteria C: Development


## List of techniques used
1) Hashing password
2) EmailAlert
3) InputValidation
4) ImageButton
5) RenderingVideo
6) Classes(Encapsulaiton adn decapsulation)
7) KivyWidgets
8) Queries Database
9) Sorting
10) Datafilter
11) FileChooser
12) API
13) TrainModel(Feeding Data) to LM
14) Moderation
15) Groq
16) Downloadable image

## list of Package/ library used

1. sqlite3
2. kivymd
3. os
4. matplotlib.pyplot as plt
5. datetime
6. hashlib
7. dotenv
8. security EmailAlert





# Criteria D: Functionality

## Video showcasing the functionality of the application




# Citation

a) Website Article:
  Lablab.ai. "Mastering AI Content Creation: Leveraging Llama 3 and Groq API." Lablab, https://lablab.ai/t/mastering-ai-content-creation-leveraging-llama-3-and-groq-api. Accessed 11 Mar. 2025.

b) YouTube Videos:

1. YouTube. "How to Use AI for Content Creation.", YouTube, https://www.youtube.com/watch?v=YlRd4rw_vBw&t=40s.
2 YouTube. "Llama 3 and Groq API Overview."  YouTube, https://www.youtube.com/watch?v=A3AXi9WjuQM.
3. YouTube. "Python Simple Hashing."  YouTube, https://www.youtube.com/results?search_query=python+simple+hasing.
4. YouTube. "Email Alert with Python."  YouTube, https://www.youtube.com/results?search_query=emailalert+with+python.
5. YouTube. "Python Email Alert Tutorial." YouTube, https://www.youtube.com/watch?v=G-Rp41BzGxg&t=375s.
6 YouTube. "Understanding ScreenManager in Kivy." , YouTube, https://www.youtube.com/watch?v=vtpFfnb6pmY.
7. YouTube. "Sorting with Python. https://www.youtube.com/results?search_query=sorting+with+python.
8. YouTube. "Querying a Database." YouTube, https://www.youtube.com/results?search_query=query+database.
9. YouTube. "Database Query Basics." YouTube, https://www.youtube.com/watch?v=3vsC05rxZ8c.
c) Documentation & Blog:

1. "ScreenManager — Kivy API Documentation." Kivy.org, https://kivy.org/doc/stable/api-kivy.uix.screenmanager.html. Accessed 11 Mar. 2025.
2. Tapitapi. "Kivy UIX ScreenManager Guide." Qiita, https://qiita.com/tapitapi/items/a4a4e3a7164afd922115. Accessed 11 Mar. 2025.




## Main file: "project_3.py"

## Importing methods that I need in building the application

```.py

from mylib import DatabaseManager, get_hash, check_hash

```
I imported two methods and a class: get_hash, check_hash, and DatabaseBase from a local file called "Mylib". The DatabaseManager class helps me connect to the relational database that stores all the data in this project. It allows me to interact with the database through python by running the SQL queries. The two main methods inside the DatabaseManager class are run_query and search. Run query allows me to run a SQL query through python, while the search method can return the result of the query ran. 

```.py
class DatabaseManager:
    def __init__(self, name: str):
        self.connection = sqlite3.connect(name)
        self.cursor = self.connection.cursor()

    def search(self, query: str, params: tuple = ()):
        result = self.cursor.execute(query, params).fetchall()
        return result

    def save(self, query: str):
        self.cursor.execute(query)
        self.connection.commit()

    def execute(self, insert_query: str, param: tuple):
        self.cursor.execute(insert_query, param)
        self.connection.commit()

    def close(self):
        self.connection.close()

```
Above class "DatabaseManager, is a simple way to interact with an SQLite database. First method is constructor which runs when you create an object from the class. It connects to an SQLite dtabase with given by the name. It creates a cursor, which allows us to run SQL commands. The second method called search is for retriving data from database. It fetches the data and run the given SQL "query" with optional params(e.g, filtering results). atlast this method will return the result as a list of tuples. The save method runs an SQL command that does not need parameters, it commit changes to make them permanent. Excute methods run SQL command that help us to insert or update specific rows with the values. And finally the close function will close the database when we are done to avoid data overflow.


```.py
from passlib.hash import pbkdf2_sha256 as hash_function

def get_hash(text: str):
    return hash_function.hash(text)


def check_hash(input_hash, text):
    return hash_function.verify(text, input_hash)

```

Two other methods I imported are get_hash and check_hash. The get_hash method takes a string as the input, and returns another string encrypted by the sha-256 encryption from the passlib library. This method allows me to encrypt user data so that they are safe from unauthorized agent and possible information leaks.

The check_hash function takes the plain text, hashes it and verify if it matchs with previously stored hash. This method helps me with the login system and validation system. 

## Review and Rating Code(Success Criteria 1)

As stated in success criteria, my client required a reviews and ratings system, so users and food critics can rewiews and rate on each dishes.
```.py

def open_review_dialog(self, food_name, instance, touch):
    # Check if the touch is within the bounds of the image
        if instance.collide_point(*touch.pos):
            # Create TextInput for review input
            self.review_input = TextInput(
                hint_text=f"Write a review for {food_name}",  # Placeholder text
                size_hint_y=None,
                height="40dp",  # Ensure it has enough height
                multiline=False  # Single-line input
            )

            # Star rating variables
            self.rating = 0  # Default rating is 0
            self.star_buttons = []  # List to store star buttons

            # Here we are Creating a BoxLayout for star ratings
            star_layout = BoxLayout(orientation="horizontal", spacing="5dp", size_hint_y=None, height="40dp")
            for i in range(1, 6):  # Create 5 stars
                star_button = MDIconButton(
                    icon="star-outline",  # Default star icon
                    theme_icon_color="Custom",
                    icon_color=(1, 1, 0, 1),  # Yellow color for stars
                    on_release=lambda x, index=i: self.update_rating(index)
                )
                self.star_buttons.append(star_button)
                star_layout.add_widget(star_button)

            # This BoxLayout is use to hold the label, stars, and TextInput
            content_box = BoxLayout(orientation="vertical", spacing="10dp", size_hint_y=None, height="160dp")
            content_box.add_widget(MDLabel(text=f"Rate and Review {food_name}:", theme_text_color="Custom", text_color=(1, 1, 1, 1)))
            content_box.add_widget(star_layout)  # Add star rating layout
            content_box.add_widget(self.review_input)

            # Create and show the dialog with "Cancel" and "Submit" buttons
            self.review_dialog = MDDialog(
                title="Rate and Review",
                type="custom",
                content_cls=content_box,  # Use the BoxLayout as content_cls
                md_bg_color=[0, 0, 0, 1],)  # Black background

```
The open_review_dialog method is responsible for initializing and displaying a modal dialog that allows users to rate and review a specific food item. It first verifies whether the touch event occurred within the bounds of the image instance using collide_point(*touch.pos). If the condition is met, it dynamically creates a TextInput widget with a predefined height and single-line constraint to capture the user’s review input.

Additionally, the method initializes a star rating system by generating five MDIconButton instances with an outlined star icon and a yellow color scheme. Each button is assigned a lambda function that invokes update_rating(index), dynamically updating the rating based on user interaction. The buttons are stored in a list (self.star_buttons) for later manipulation.

A BoxLayout is then constructed to house the star buttons in a horizontal arrangement, while another vertical BoxLayout (content_box) encapsulates the rating label, the star rating layout, and the review input field. This structured layout is then assigned as the content_cls of an MDDialog, which is instantiated with a custom dark background theme. The dialog features predefined "Cancel" and "Submit" actions, allowing users to either discard or submit their review.



### Submiting the Reviews and Rating to Database


```.py
cursor.execute("""
                INSERT OR REPLACE INTO aggregate_ratings (
                    food_name, total_ratings, average_rating,
                    star_5_percent, star_4_percent, star_3_percent, star_2_percent, star_1_percent
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                food_name,
                total_ratings,
                average_rating,
                star_percentages[5],
                star_percentages[4],
                star_percentages[3],
                star_percentages[2],
                star_percentages[1]
            ))

```
After user input reviews and stared it the execute method from the DatabaseManager class is 
used to insert reviews and ratings into the database. It runs a parameterized query and commits the changes automatically, ensuring data is securely inserted into the reviews table. By using placeholders (?), it prevents SQL injection and binds input values to the query, making it the ideal method for inserting data.

# Featuring Dishes with Sorting algorithm with rating(Sucess Criteria 2)

```.py

def sort_food_by_rating(self):
    cursor = DatabaseManager.connection.cursor() 
    # Fetch average ratings for all food items
    ratings_data = DatabaseManager.search("""
    SELECT food_name, average_rating
    FROM aggregate_ratings
""")
    ratings_data = cursor.fetchall()

    # Create a dictionary to map food names to their average ratings
    ratings_dict = {food_name: avg_rating for food_name, avg_rating in ratings_data}

    # Sort food_images by average rating (descending order)
    elf.food_images.sort(
    key=lambda food: ratings_dict.get(food["name"], 0),  # Default rating is 0 if not found
            reverse=True
        )

    # Reload the menu to reflect the sorted order
    self.load_menu()


        ```
To integrate the DatabaseManager into the existing code for fetching ratings data, the direct use of DB_CONNECTION can be replaced with the DatabaseManager's methods. Instead of manually calling DB_CONNECTION.cursor(), the connection attribute from the DatabaseManager instance (DatabaseManager.connection.cursor()) can be used. This allows the cursor functionality to be maintained within the context of the DatabaseManager class.

Next, instead of using cursor.execute() and cursor.fetchall(), the search() method from DatabaseManager can be used. The search() method is designed to execute a query and return the results directly, so it replaces the cursor.execute() and cursor.fetchall() pattern. This simplifies the code and leverages the functionality of DatabaseManager for both executing queries and retrieving data.

```.py

def plot_graph(self):
        food_names, ratings = self.get_food_ratings()
        
        # Create the bar plot
        plt.bar(food_names, ratings, color='skyblue')
        plt.xlabel('Food Items')
        plt.ylabel('Rating')
        plt.title('Food Ratings Distribution')
        

        plt.ylim(0, 6)  # Extend y-axis to 6 to avoid touching the ceiling
        
        # Set y-axis ticks to include 1 through 6 as our graph is ugly when touched up
        plt.yticks([1, 2, 3, 4, 5, 6])
        
        # Rotate x-axis labels to prevent overlap
        plt.xticks(rotation=45, ha="right")  # Rotate by 45 degrees and align to the right

        # Display in Kivy UI
        self.add_widget(FCK(plt.gcf()))  # gcf = Get Current Figure
```
The plot_graph method works by first retrieving the food ratings and their corresponding names through the get_food_ratings method. This data is then used to generate a bar plot using Matplotlib’s plt.bar, where food names are plotted on the x-axis and their ratings are represented on the y-axis. The method customizes the plot by setting the y-axis range slightly above the maximum rating value, ensuring the bars do not touch the top of the plot. The y-ticks are specifically defined to show values from 1 to 6 to match the expected rating scale. To improve the readability of the x-axis, the labels are rotated 45 degrees and aligned to the right to avoid overlap. Finally, the current Matplotlib figure (plt.gcf()) is added as a Kivy widget, integrating the generated plot directly into the Kivy UI via the FCK widget, allowing dynamic visualization of the ratings in the app.

```.py

def save_graph(self, instance):
        # Get name from the textinput
        filename = self.filename_input.text.strip()
        # validate for name
        if not filename:
            filename = "Food_Ratings"  # Default filename if nothing is entered
        # Ensure the target directory exists
        target_directory = os.path.join(os.path.expanduser("DragonWarrior/Desktop/Unit3_Repo/Project-3/image"), "Downloads")
        if not os.path.exists(target_directory):
            os.makedirs(target_directory)  # Create the directory if it doesn't exist
        # Save the plot directly to the fixed location with the custom filename
        plt.savefig(fixed_path)  
        # Show a "Downloaded" message
        self.show_download_message(fixed_path)
        # Close the popup after saving
        self.popup.dismiss()
    def show_download_message(self, filepath):
        """ Display a message saying the file was downloaded. """
        message = f"Downloaded: {os.path.basename(filepath)}"
        
        # Create a new popup with an OK button and a label
        download_popup_content = BoxLayout(orientation='vertical', spacing=10)
        download_popup_content.add_widget(Label(text=message))  # Display download message
        ok_button = Button(text='OK', size_hint=(None, None), size=(100, 40))  # OK button
```
After we the graph plotted we can download it with save_graph method which works by first retrieving the filename entered by the user through a TextInput widget, defaulting to "Food_Ratings" if no input is provided. It then ensures the target directory exists (in this case, a Downloads folder on the desktop) and creates it if necessary. The path for saving the plot is constructed using the user's filename and the fixed directory path. The Matplotlib plot is then saved as a PNG file at this location using plt.savefig. After saving the plot, a confirmation message is displayed using a popup that shows the name of the downloaded file. Finally, the dismiss_popup method allows the user to cancel and close the popup if needed, while the show_download_message method displays the successful download message in a new popup. This approach allows the user to dynamically save and confirm the saved plot image on their desktop.

fig.1: shows graph downloading



### Communicating with groq Api for chatbot(sucess criteria 3)


```.py
from groq import Groq
from dotenv import load_dotenv

groq_api_key = os.getenv("GROQ_API_KEY")

client = Groq(api_key=groq_api_key)
class ChatbotScreen(Screen):
    def on_enter(self):
        greeting_message = "Hi there! I am the DragonWarrior. I can also give recipe of anything!"
        self.add_message(f"DragonWarrior: {greeting_message}", "left")

    def send_message(self):
        user_input = self.ids.user_input.text.strip()

        if not user_input:
            return  # Ignore empty messages

        # Prepend "You:" to the user's message
        self.add_message(f"You: {user_input}", "right")

        # Clear input field
        self.ids.user_input.text = ""

        # Process message with Groq AI (non-blocking)
        Clock.schedule_once(lambda dt: self.get_bot_response(user_input), 0)

    def get_bot_response(self, user_query):
        """Fetch response from Groq AI and display it."""
        message- [{"role":"system", "content": Assistant},{"role": "user", "content": user_query}]
        response = client.chat.completions.create(
                model="qwen-2.5-32b",  ## better than deepseek and ollama
                messages=messages
            )

        ## "............continue--- for the kivy and other widget"

```

First it will get the api from the .env file for security because when I push it in github the api key is leaked. So, to prevent that we use inbuild library called dotenv which will graph and hide api key. res the code integrates the Groq AI with a Kivy-based chatbot interface by initializing the Groq client with an API key retrieved from an environment variable. When the ChatbotScreen is displayed, a greeting message is added to the chat interface. The user’s message is formatted with a "You:" prefix and sent to the interface, after which the input field is cleared. To ensure the UI remains responsive, the message query is processed asynchronously using Clock.schedule_once, which schedules the AI query to run in the next event loop iteration. The get_bot_response method constructs a message payload with the user input and a system message, which is then sent to Groq's chat.completions.create() method for a response. This non-blocking approach prevents UI freezing, enabling a smooth user experience while awaiting the AI's response.

